#pragma once

#include <G3D/G3DAll.h>
#include <iostream>
#include <fstream>
#include <stdio.h>
#include <map>
#include <set>

#include "SceneFile.h"
#include "ColorMapper.h"

/*
Change Log:
- File created by Melanie, Kenny, Yitong, and Cole (midterm)
*/

/** A class to generate a virtual world. **/
class Mesh {
protected:

    /** A class to keep track of the normal at a vertex. **/
    class VertexNormalIndexPair {
    public:
        int vertexIndex;
        int normalIndex;
        VertexNormalIndexPair(int vertexIndex) : vertexIndex(vertexIndex), normalIndex(-1) {};
        VertexNormalIndexPair() {};
    };

    /** A class to define an edge based on the indices of its two end vertices. **/
    class Edge {
    public:
        int ind1;
        int ind2;
        Edge::Edge(int _ind1, int _ind2) : ind1(_ind1), ind2(_ind2) {}; 
    };

    /** A method of comparing two edges using the Cantor pairing function which uniquely maps two integers to one integer
     https://en.wikipedia.org/wiki/Pairing_function **/
    struct cmpEdges {
        bool operator()(const Edge& a, const Edge& b) const {
            return (a.ind1 + a.ind2) * (a.ind1 + a.ind2 + 1) / 2 + a.ind1 < (b.ind1 + b.ind2) * (b.ind1 + b.ind2 + 1) / 2 + b.ind1;
        }
    };

    // Geometry of the mesh
    Array<Vector3> vertices;
    Array<Vector3> normals;
    Table<Color3, Array<VertexNormalIndexPair>> indexGroups;
    
    // Base image and Scene file
    shared_ptr<Image>& image; 
    shared_ptr<SceneFile>& sceneFile;
    
    // Heightfield parameters
    float xScale;
    float yScale;
    float zScale;

    // Point sampling parameters
    int numRandomSampledPts;
    int numImportanceSampledPts;
    bool addPointsAboveThreshold;
    float interestingThreshold;
    
    // Terrain generation parameters
    int terrainSize;
    int terrainGran;
    float terrainPower;
    int terrainOffset;

    // Density of sheep
    float areaPerSheep;

    // Voronoi diagram for field coloring
    shared_ptr<Image> colormap;

    // Keeps track of field adjacency for tree placement
    std::map<Edge, Color3, cmpEdges> fieldEdges;

    /** Get the color for a surface. **/
    void getColor(const shared_ptr<Image>& colormap, int terrainSize, const Vector3& triangleCenter, const Vector3& normal, Color3& color, shared_ptr<Image> biome, const Triangle& triangle, const int a, const int b, const int c);
 
    /** Simple threshold-based coloring function for terrain using altitude and normal. **/
    Color3 thresholdColoring(float y, float flatness);

    /** Continues coloring function for terrain. **/
    Color3 continuousColoring(const Vector3& position, const Vector3& normal);

    /** Save the necessary vertex information for the Python Delauney triangulator. **/
    static void savePythonInput(const std::string& fileName, Array<Vector3>& sampledVertices);

    /** Save the heightfield Materials file. **/
    void saveMtl(const std::string& fileName) const;

    /** Save the heightfield Object file. **/
    void saveObj(const std::string& fileName, const std::string& mtlFileName) const;

    /** Compute the surface normals. **/
    void computeNormals();

    /** Add sheep to the terrain. **/
    void addSheep(const Triangle& triangle); 

    /** Add a row of trees. **/
    void addTrees(const int a, const int b, Color3 color, const Vector3& normal);
    
    /** Adds n clouds to the scene at random X and Z coordinates with Y set 2x higher than the highest mountain. **/
    void addClouds(int n);

    /** Interpolate Tree positioning along a field edge. **/
    void lerpTrees(Point3 point1, Point3 point2, const Vector3& normal = Vector3(0, 1, 0));

    /** Helper function that sets (x,y) in heights with a Color3 where rgb are set to value. **/
    void setSample(shared_ptr<Image> heights, int x, int y, float value);

    /** Helper function that returns the average value of the color found in (x,y) of image heights. **/
    float sample(shared_ptr<Image> heights, int x, int y);

    /** Creates an image that specifies where water and its surronding hills should go in a scene. **/
    shared_ptr<Image> genWaterDist(int n);

    /** Given a waterBiome image, specifies where hills, foothills, mountains and farms should be located in the remaining space of the scene. **/
    void genBiomeDist(shared_ptr<Image> water, int n);

    /** Given a complete Biome specification, creates an image that can be translates into a heightfield that represents that an entire Scene. **/
    shared_ptr<Image> genPerlinTerrain(int n, int gran, float power, int offset, shared_ptr<Image> biome);

    /** Populates the mesh with the indices generated by the Delaunay triangulation script and colors them. **/
    void generateDelaunayTriangulationMesh(shared_ptr<Image> biome, Array<Vector3>& vertices);

    /** Adds vertices that are considered influential. Vertices whose normals differ from adjacent normals are considered more influential. */
    void thresholdSampling(const shared_ptr<Image>& image, float interestingThreshold, float xScale, float yScale, float zScale, Array<Vector3>& vertices);
public:
    Mesh(                     shared_ptr<Image>& _image, 
                            shared_ptr<SceneFile>& _sceneFile,
                                                float _xScale,
                                                float _yScale,
                                                float _zScale,
                                     int _numRandomSampledPts,
                                 int _numImportanceSampledPts,
                                bool _addPointsAboveThreshold,
                                  float _interestingThreshold,
                                             int _terrainSize,
                                             int _terrainGran,
                                          float _terrainPower,
                                           int _terrainOffset,
                                           float areaPerSheep,
                                 shared_ptr<Image> _colormap);

    /** Generate a terrain heightfield. **/
    void genHeightField();

    /** Save the Object and Materials Files. **/
    void saveObjMtlFiles(const std::string& objFileName, const std::string& mtlFileName, const std::string& pythFileName);
};